{
  "name": "eventreactor",
  "description": "EventEmitters on a syntax suger rush",
  "version": "0.0.6",
  "author": {
    "name": "Arnout Kazemier",
    "email": "opensource@observe.it"
  },
  "homepage": "http://observe.it",
  "keywords": [
    "event",
    "eventemitter",
    "observer"
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/observing/eventreactor.git"
  },
  "devDependencies": {
    "should": "*",
    "mocha": "*"
  },
  "scripts": {
    "test": "make test"
  },
  "readme": "# EventReactor, EventEmitters on a sugar rush\n\nBuild status: [![BuildStatus](https://secure.travis-ci.org/observing/eventreactor.png)](http://travis-ci.org/observing/eventreactor)\n\nI could have come up with a lame name like `eventemitters`, `eventemitter3` or\n`event`. But I decided not to do that and just go with something completely odd.\n\nBut what does it do? I add some additional syntax suger on top of the existing\nEventEmitter's in node.js. They are all nice pretty, but when you are working\nwith loads of events you find your self repeating the same things over and over\nagain.. wondering if it couldn't be simpler than that.\n\n## New methods, API\n\n### EventEmitter.every(event, event, event, callback);\n\nApplies the same callback for all the given events. It expects that the callback\nis the last argument of the function and that all other arguments are the name\nof the events you want to listen on.\n\n#### Example\nYou find your self applying the same error handling for timeouts, errors and\nother error related events. This cleans up your code nicely\n\n```js\nvar EventEmitter = process.EventEmitter;\nrequire('eventreactor');\n\nvar EE = new EventEmitter;\nEE.every('error', 'timeout', function (e) {\n console.error('(error) ', e.message);\n});\n```\n\n### EventEmitter.has(event, fn);\n\nCheck if the EventEmitter already has this function applied, if your code has\nmultiple parts on where events can be added to your event emitter you might want\nto check if it's not added already. This simple helper function returns true or\nfalse.\n\n#### Example\n\n```js\n// same init as above\nvar EE = new EventEmitter;\n\nfunction example () {};\n\nif (!EE.has('example', example)) {\n  EE.on('example', example);\n}\n```\n\n### EventEmitter.multiple({object});\n\nSometimes you need to add a lot of event listeners for example when you create a\nnet.Connection. You need to listener for error, close, connect, data, timeout\nand maybe even for end. That is a lot of events.\n\nOr maybe you are already used to a observer patterns that used objects for\nlistening instead of eventlistener based layout. Anyways, we got you covered.\n\n#### Example\n\n```js\n// same init as first example\nvar EE = new EventEmitter;\n\nEE.multiple({\n    error: function () { .. }\n  , timeout: function () { .. }\n  , connect: function () { .. }\n  , close: function () { .. }\n});\n```\n\n### EventEmitter.idle(event, timeout, callback /*, argument1, argument2 ... */);\n\nSometimes you want to know when an event has not been fired within a specified\ntime period.  You can set an idle timer that fires off a callback for you if the\nevent has gone missing.  Once fired, the event will remove itself for you, so\ndon't forget to set it back up after your events start up again.\n\nDon't worry, like a good idle timer, it will reset itself when the event has\nbeen fired before the timeout has occurred.\n\n#### Example\n\n```js\n// same init as first example\nvar EE = new EventEmitter;\n\nfunction callback (event) {\n  console.log(event + \" was never fired\");\n}\n\nEE.idle(\"timeout\", 100, callback);\n```\n\n### EventEmitter.delay(event, timeout /*, argument1, argument2 .. */);\n\nDelays the emitting of the given event. Much like setTimeout invokes the\nfunction after xxx miliseconds.\n\n#### Example\n\n```js\nvar EE = new EventEmitter;\n\nEE.on('foo', function (arg, arg1) {\n  console.log('args: ', arguments);\n});\n\nEE.delay('foo', 1000, 'arg1', 'arg2');\n```\n\n### EventEmitter.defer(event /*, argument1, argument2 .. */);\n\nDefers the emitting of the event until the current call stack has been cleared.\nSimular to wrapping an emit in a `process.nextTick`.\n\n#### Example\n\n```js\nvar EE = new EventEmitter;\n\nEE.on('pewpew', function () {\n  console.log('called second', arguments);\n});\n\nEE.defer('pewpew', 1, 2, 3);\n\nconsole.log('called first');\n```\n\n### Uncaught events\n\nEventReactor comes with the ability to capture uncaught events. These are events\nthat don't have listeners assigned to them. It's currently hidden behind a\npreference flag because it needs to override the existing `emit` method in order\nto make this work.\n\n#### Example\n\n```js\nvar EventReactor = require('eventreactor');\nEventReactor(true); // turn on uncaught events\n\nvar EE = new EventEmitter;\n\nEE.on('uncaught', function (event, data) {\n  console.log('no listeners for', event, data);\n});\n\nEE.emit('random name');\n```\n\n### Aliases\n\n- `EventEmitter.off` -> `EventEmitter.removeListener`\n- `EventEmitter.removeEventListener` -> `EventEmitter.removeListener`\n- `EventEmitter.addEventListener` -> `EventEmitter.addListener`\n",
  "readmeFilename": "Readme.md",
  "bugs": {
    "url": "https://github.com/observing/eventreactor/issues"
  },
  "_id": "eventreactor@0.0.6",
  "_from": "eventreactor@0.0.x"
}
